[{"content":"\rIntrodução Se você ainda não conferiu nosso tutorial sobre Teoria dos Jogos no R, abordando Jogos Simultâneos, clique aqui para acessar diretamente o post.\nPacotes Para realização dos passos seguintes, será necessário a instalação e ativação do pacote:\n# install.packages(\u0026#34;devtools\u0026#34;) # devtools::install_github(\u0026#34;yukiyanai/rgamer\u0026#34;) library(rgamer) library(utf8) Jogos Sequenciais Jogos sequenciais são modelos que representam a tomada de decisão em sequência, levando em conta as escolhas dos jogadores e as informações disponíveis. A análise desses jogos envolve a busca por estratégias ótimas e a previsão dos desdobramentos com base nessas estratégias. Na aplicação de jogos sequenciais no R, há funções que auxiliam na construção gráfica da forma extensiva e sequencial do jogo.\nForma Extensiva\rForma Sequencial\rNa representação extensiva, podemos utilizar o exemplo mencionado anteriormente da guerra de preços entre dois postos de gasolina. Nessa estrutura de jogo, ao contrário da forma normal, os jogadores tomam decisões em uma ordem específica. Começando com o posto \u0026ldquo;OilFlex\u0026rdquo;, que é o jogador inicial e tem um nó na árvore de decisão, e \u0026ldquo;EconoGas\u0026rdquo;, que é repetido duas vezes porque possui dois nós, um para cada situação em que pode reagir às ações tomadas pelo outro posto de gasolina. Essa diferenciação ocorre porque o jogador inicial, neste caso, começa a árvore de decisão, enquanto o segundo jogador reage a essa ação inicial. O mesmo princípio se aplica às estratégias no argumento actions, que consiste nas estratégias \u0026quot;Manter\u0026quot;\u0026quot; e \u0026quot;Reduzir\u0026quot; para o jogador 1 e 2.\nAo definir rep(NA, 4) dentro do argumento players, estamos indicando que os nós terminais se repetirão quatro vezes, refletindo as possíveis combinações de ações ao longo da árvore de decisão. A estrutura de payoffs é feita em uma lista com o nome dos jogadores, seguida pela especificação de seus ganhos para cada combinação de ações. Essa estrutura, diferentemente da forma normal, é necessária porque a representação extensiva é mais detalhada e explícita, mostrando a árvore de decisão completa do jogo, passo a passo, com informações sobre as ações tomadas em cada nó da árvore. Dessa forma, os payoffs são especificados separadamente para cada jogador em cada nó, permitindo uma representação detalhada das recompensas em cada cenário do jogo.\njogo7 \u0026lt;- extensive_form( players = list(\u0026#34;OilFlex\u0026#34;, c(\u0026#34;EconoGas\u0026#34;, \u0026#34;EconoGas\u0026#34;), rep(NA, 4)), actions = list(c(\u0026#34;Manter\u0026#34;, \u0026#34;Reduzir\u0026#34;), c(\u0026#34;Manter\u0026#34;, \u0026#34;Reduzir\u0026#34;), c(\u0026#34;Manter\u0026#34;, \u0026#34;Reduzir\u0026#34;)), payoffs = list(OilFlex = c(50, 30, 60, 40), EconoGas = c(50, 60, 30, 40)), show_node_id = FALSE) Quando show_node_id é definido como FALSE (sendo TRUE o valor padrão), a árvore de decisões é exibida de maneira simplificada, sem a numeração de cada nó na árvore.\nNesse outro método, iniciamos a estruturação do exemplo utilizando a função seq_form(), o que nos permite especificar as estratégias dos jogadores e os payoffs associados a cada combinação de estratégias.\nsq_jogo8 \u0026lt;- seq_form( players = c(\u0026#34;OilFlex\u0026#34;, \u0026#34;EconoGas\u0026#34;), s1 = c(\u0026#34;Manter\u0026#34;, \u0026#34;Reduzir\u0026#34;), s2 = c(\u0026#34;Manter\u0026#34;, \u0026#34;Reduzir\u0026#34;), payoffs1 = c(50, 60, 30, 40), payoffs2 = c(50, 30, 60, 40)) A partir disso, usamos a função seq_extensive() para transformar um jogo na forma sequencial, definido com seq_form(), em um jogo na forma extensiva.\njogo8 \u0026lt;- seq_extensive(sq_jogo8, direction = \u0026#34;right\u0026#34;, color_palette = \u0026#34;Dark2\u0026#34;) Ao especificarmos o parâmetro direction como \u0026quot;right\u0026quot;, a árvore extensiva é direcionada para a direita, e as cores são aplicadas de acordo com a paleta de cores especificada em color_palette.\nAlém disso, é possível utilizar funções que permitem não somente a indução manual dos caminhos, a restrição das opções dos jogadores, mas também outras funcionalidades que incluem a possibilidade da contagem de subjogos em cada ramo da forma extensiva e a transferência dos dados para matrizes. O que contribui para uma análise mais completa e coerente das possibilidades do jogo.\nFunção draw_path\rSubjogos\rMatriz\rCom a construção da estrutura da forma extensiva, podemos utilizar a função draw_path para induzir os caminhos específicos em um jogo representado em forma de árvore, definido pela função extensive_form().\ndraw_path(jogo7, actions = list(\u0026#34;Manter\u0026#34;, \u0026#34;Manter\u0026#34;)) The game reaches at n4. Payoffs: OilFlex EconoGas 50 50 The game reaches at n4. Payoffs: No R, é possível restringir as ações dos jogadores através da eliminação de certas sequências de jogadas. Essa restrição pode ser feita utilizando o parâmetro actions da função restrict_action(), que recebe uma lista de vetores. Ao utilizar essa função, é possível controlar quais jogadas são permitidas em cada estágio do jogo sequencial.\nrestrict_action(jogo7, action = list(\u0026#34;n1\u0026#34; = \u0026#34;Reduzir\u0026#34;, \u0026#34;n2\u0026#34; = \u0026#34;Reduzir\u0026#34;)) Ao observar o parâmetro action, percebemos que ele contém a identificação dos nós do jogo, neste caso, \u0026quot;n1\u0026quot; e \u0026quot;n2\u0026quot;, juntamente com as ações correspondentes, que são \u0026quot;Reduzir\u0026quot; e \u0026quot;Reduzir\u0026quot;.\nA função subgames() é usada para encontrar e identificar os subjogos dentro de um jogo em forma extensiva. Um subjogo é uma parte do jogo que pode ser analisada e tratada separadamente.\nsubgames(jogo7, quietly = FALSE) The game has 3 subgames. Ao utilizar o parâmetro quietly = FALSE, a mensagem de contagem de subjogos será exibida juntamente com os gráficos.\nA função to_matrix é usada para transformar um jogo em forma extensiva, com dois jogadores, em um jogo em forma normal. Isso permite representar o jogo em uma matriz de ganhos, onde as estratégias ou perfis de ações são especificados.\njogo7mx \u0026lt;- to_matrix(jogo7) Para visualizar o data frame que contém as matrizes dos jogadores 1 e 2, basta utilizar o objeto criado anteriormente, nomeado como jogo7mx, e acrescentar $df. Nesse data frame, as colunas payoff1 e s1 representam, respectivamente, os ganhos e as estratégias do posto OilFlex, enquanto as colunas payoff2 e s2 representam os ganhos e estratégias da EconoGas.\njogo7mx$df row column s1 s2 payoff1 payoff2 1 1 1 (Manter) (Manter, Manter) 50 50 2 1 2 (Manter) (Manter, Reduzir) 50 50 3 1 3 (Manter) (Reduzir, Manter) 30 60 4 1 4 (Manter) (Reduzir, Reduzir) 30 60 5 2 1 (Reduzir) (Manter, Manter) 60 30 6 2 2 (Reduzir) (Manter, Reduzir) 40 40 7 2 3 (Reduzir) (Reduzir, Manter) 60 30 8 2 4 (Reduzir) (Reduzir, Reduzir) 40 40 Na visualização dos payoffs de cada jogador, é necessário utilizar a função matrix() em jogo7mx$mat$matrix1. Desse modo, é possível identificar as jogadas e os ganhos do jogador 1.\n# Payoff do posto \u0026#34;OilFlex\u0026#34; matrix(jogo7mx$mat$matrix1, nrow = 2, dimnames = list(c(\u0026#39;M\u0026#39;, \u0026#39;R\u0026#39;), c(\u0026#39;MM\u0026#39;, \u0026#39;MR\u0026#39;, \u0026#39;RM\u0026#39;, \u0026#39;RR\u0026#39;))) MM MR RM RR M 50 50 30 30 R 60 40 60 40 Ao utilizar o argumento dimnames para especificar os nomes das colunas e linhas de uma matriz. Dessa forma, é implementada por meio de uma lista, permitindo uma representação mais intuítiva das ações dos jogadores (Manter e Reduzir) e dos payoffs correspondentes ao jogador 1 e 2.\n# Payoff do posto \u0026#34;EconoGas\u0026#34; matrix(jogo7mx$mat$matrix2, nrow = 2, dimnames = list(c(\u0026#39;M\u0026#39;, \u0026#39;R\u0026#39;), c(\u0026#39;MM\u0026#39;, \u0026#39;MR\u0026#39;, \u0026#39;RM\u0026#39;, \u0026#39;RR\u0026#39;))) MM MR RM RR M 50 50 60 60 R 30 40 30 40 Quando utilizamos o argumento nrow = 2, estamos essencialmente informando que a matriz terá duas linhas, cada uma representando as ações \u0026ldquo;Reduzir\u0026rdquo; ('R') e \u0026ldquo;Manter\u0026rdquo; ('M'). Vale notar que, ao especificar o número de linhas, o ambiente R define automaticamente o número de colunas com base nessa especificação.\nEq. de Nash Perfeito em Subjogos O Equilíbrio de Nash Perfeito em Subjogos (ENPS) é um conceito utilizado na teoria dos jogos para analisar estratégias em jogos sequenciais. Ele consiste em um conjunto de estratégias, uma para cada jogador, que representa um equilíbrio de Nash em cada subjogo do jogo original.\nFunção solve_efg\rFunção solve_seq\rO solve_efg permite encontrar soluções para jogos em forma extensiva. Ele recebe como entrada um jogo em forma extensiva definido previamente e retorna uma lista de soluções encontradas, baseadas no conceito de solução escolhido pelo usuário.\nExistem duas opções para o conceito de solução: \u0026quot;backward\u0026quot; (Indução Retroativa) e \u0026quot;spe\u0026quot; (Equilíbrio Perfeito em Subjogos), ambos obtêm o mesmo resultado.\nsolve_efg(jogo7, concept = \u0026#34;backward\u0026#34;, quietly = FALSE) backward induction: [(Reduzir), (Reduzir, Reduzir)] Ou pode-se chegar ao gráfico de melhores respostas pelo comando show_path().\nshow_path(jogo7) Também é possível obter a tabela a partir da matriz usando a função solve_nfg() e determinar os equilíbrios de Nash e Equilíbrio de Nash Perfeito em Subjogos a partir das informações mencionadas no tópico anterior.\n# Matriz do jogo 7 jogo7mxtab \u0026lt;- solve_nfg(jogo7mx) Pure-strategy NE: [(Reduzir), (Reduzir, Reduzir)] EconoGas\rstrategy (Manter, Manter) (Manter, Reduzir) (Reduzir, Manter) (Reduzir, Reduzir) OilFlex (Manter) 50, 50 50^, 50 30, 60^ 30, 60^ (Reduzir) 60^, 30 40, 40^ 60^, 30 40^, 40^ Assim, o ENPS ocorre quando o posto EconoGas adota as estratégias de \u0026ldquo;Reduzir, Reduzir\u0026rdquo;, em resposta à redução de preços realizada pelo posto OilFlex.\nO solve_seq aceita um jogo em forma sequencial como entrada e retorna os equilíbrios de Nash encontrados, se houver. Além disso, ele também pode exibir uma tabela com as jogadas e estratégias ótimas para cada jogador, facilitando a análise e compreensão dos resultados.\nNo exemplo anterior, utilizamos a função seq_form() para estruturar um jogo na forma sequencial, a partir de uma forma normal. Em seguida, aplicamos o solve_seq() para transformar o jogo da forma extensiva novamente para a forma normal.\nsolve_seq( sq_jogo8, show_table = TRUE, mark_br = FALSE, precision = 1L, quietly = FALSE ) SPE outcome: (Reduzir, Reduzir) EconoGas\rstrategy Manter Reduzir OilFlex Manter 50, 50 60, 30 Reduzir 30, 60 40, 40 Já o argumento precision afeta a formatação dos valores exibidos na tabela de solução, determinando o número de casas decimais a serem apresentadas. Por exemplo, ao definir precision = 1L, os valores serão arredondados para uma casa decimal, já que o uso de 1L assegura que a precisão seja interpretada como um número inteiro.\nEncontrar o ENPS envolve analisar cada subjogo, identificar os equilíbrios de Nash em cada um e verificar se esses equilíbrios são compatíveis entre si ao longo de todo o jogo. Caso exista um conjunto de estratégias que satisfaça essas condições, temos um Equilíbrio de Nash Perfeito em Subjogos.\nJogos Repetidos Em jogos repetidos é possível definir os jogadores envolvidos e as ações disponíveis para cada um em cada rodada, de forma que os payoffs podem ser atribuídos a diferentes combinações de ações ao longo do tempo. Esse enfoque permite uma exploração mais profunda das complexas dinâmicas estratégicas que emergem quando os jogadores interagem repetidamente. À medida que eles se envolvem em múltiplas rodadas é ajustado suas estratégias com base nas escolhas anteriores dos adversários, construindo gradualmente um aprendizado estratégico.\nJogos Repetidos Finitos Considerando um exemplo de jogo repetido finito entre dois países, \u0026quot;P1\u0026quot; e \u0026quot;P2\u0026quot;, que estão em um cenário de possíveis conflitos e cooperação, representados pelas ações de \u0026ldquo;Guerra\u0026rdquo; (\u0026quot;G\u0026quot;) e \u0026ldquo;Paz\u0026rdquo; (\u0026quot;P\u0026quot;). Nesse contexto, os jogadores estão envolvidos em quatro períodos de decisão. Eles estão avaliando se devem optar por \u0026ldquo;Guerra\u0026rdquo; ou \u0026ldquo;Paz\u0026rdquo; em cada período.\nComparando com a estrutura de Jogos Sequenciais, onde o argumento players continha rep() apenas no final e era definido por NA juntamente com o número de nós terminais. Em Jogos Repetidos, podemos utilizar a função rep() de forma mais detalhada.\nNesse caso, começamos com as jogadas de P2, pois as ações de P2 se repetirão sequencialmente após a ação do jogador inicial. Portanto, usamos \u0026quot;P2\u0026quot;, 2 e assim por diante. Em sequência, teremos \u0026quot;P1\u0026quot;, 4, o que significa que cada nó da jogada anterior de P2 se ramificará em dois nós, representando os 4 nós de P1. Na configuração rep(NA, 16), o valor NA indica que não há mais jogadas de nenhum jogador, apenas os nós terminais, que serão 16.\nNessa situação, especificamos duas estratégias para ambos os jogadores. Consequentemente, o número de repetições dos nós será sempre o dobro do anterior, como ilustrado abaixo.\njogo9 \u0026lt;- extensive_form( players = list(\u0026#34;P1\u0026#34;, # n1 rep(\u0026#34;P2\u0026#34;, 2), # n2 e n3 rep(\u0026#34;P1\u0026#34;, 4), # n4 - n7 rep(\u0026#34;P2\u0026#34;, 8), # n8 - n15 rep(NA, 16)), # Nós terminais actions = list( c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n1 - n3 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n4 - n6 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n7 - n9 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n10 - n12 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;) # n13 - n15 ), payoffs = list( P1 = c(6, 5, 6, 4, 5, 3, 6, 2, 8, 4, 7, 6, 7, 3, 6, 4), P2 = c(8, 5, 6, 4, 7, 5, 6, 8, 6, 2, 3, 3, 6, 3, 4, 7) ), direction = \u0026#34;down\u0026#34;, show_node_id = FALSE ) O exemplo acima possui uma estrutura de árvore com 15 nós, numerados de n1 a n15. Em cada nó, os jogadores têm a opção de escolher entre duas ações. Por exemplo, os três primeiros nós (n1 a n3) representam as escolhas de ação dos jogadores no primeiro período.\nAo resolver o jogo acima por indução retroativa é possível visualizar as estratégias escolhidas pelos dois jogadores.\ns_jogo9 \u0026lt;- solve_efg(jogo9, concept = \u0026#34;backward\u0026#34;, quietly = FALSE) backward induction: [(P, G, G, G, G), (G, G, G, G, G, P, G, G, G, P)], [(P, G, G, G, G), (G, P, G, G, G, P, G, G, G, P)], [(P, P, G, G, G), (P, G, G, G, G, P, G, G, G, P)], [(P, P, G, G, G), (P, P, G, G, G, P, G, G, G, P)], [(P, G, G, G, G), (G, G, G, G, G, P, G, P, G, P)], [(P, G, G, G, G), (G, P, G, G, G, P, G, P, G, P)], [(P, P, G, G, G), (P, G, G, G, G, P, G, P, G, P)], [(P, P, G, G, G), (P, P, G, G, G, P, G, P, G, P)] Em jogos repetidos, as árvores de decisão geralmente se tornam mais complexas, devido à repetição das jogadas pelos jogadores. Como observado anteriormente, foram identificadas oito soluções por meio da análise de indução retroativa.\ns_jogo9$sols [[1]] [1] \u0026#34;[(P, G, G, G, G), (G, G, G, G, G, P, G, G, G, P)]\u0026#34; [[2]] [1] \u0026#34;[(P, G, G, G, G), (G, P, G, G, G, P, G, G, G, P)]\u0026#34; [[3]] [1] \u0026#34;[(P, P, G, G, G), (P, G, G, G, G, P, G, G, G, P)]\u0026#34; [[4]] [1] \u0026#34;[(P, P, G, G, G), (P, P, G, G, G, P, G, G, G, P)]\u0026#34; [[5]] [1] \u0026#34;[(P, G, G, G, G), (G, G, G, G, G, P, G, P, G, P)]\u0026#34; [[6]] [1] \u0026#34;[(P, G, G, G, G), (G, P, G, G, G, P, G, P, G, P)]\u0026#34; [[7]] [1] \u0026#34;[(P, P, G, G, G), (P, G, G, G, G, P, G, P, G, P)]\u0026#34; [[8]] [1] \u0026#34;[(P, P, G, G, G), (P, P, G, G, G, P, G, P, G, P)]\u0026#34; Utilizando o nome do objeto criado, s_jogo9, em conjunto com o atributo $n_sols, é possível obter o número total de soluções, que neste contexto específico é representado como [1] 8. Em uma análise mais aprofundada de uma das soluções, podemos escolher a primeira solução por meio da combinação entre s_jogo9 e $trees[[1]], que corresponde à representação visual da solução $sols[[1]], ou seja, a primeira solução em formato de árvore.\ns_jogo9$trees[[1]] Para cada solução em formato de combinação ($sols) é possível se chegar a uma representação gráfica em árvore de decisão ($trees).\nParâmetro info_sets\r3 Jogadores\rOs conjuntos de informações podem ser especificados no argumento info_sets, agrupando, dessa forma, os nós nos quais um jogador não consegue distinguir as ações tomadas por seu oponente. Por exemplo, os nós n2 e n3 formam um conjunto de informações para o jogador P1, indicando que ele não sabe qual ação o jogador P2 escolheu nos nós n2 e n3.\njogo9info \u0026lt;- extensive_form( players = list(\u0026#34;P1\u0026#34;, # n1 rep(\u0026#34;P2\u0026#34;, 2), # n2 e n3 rep(\u0026#34;P1\u0026#34;, 4), # n4 - n7 rep(\u0026#34;P2\u0026#34;, 8), # n8 - n15 rep(NA, 16)), # Nós terminais actions = list( c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n1 - n3 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n4 - n6 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n7 - n9 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n10 - n12 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;) # n13 - n15 ), payoffs = list( P1 = c(6, 5, 6, 4, 5, 3, 6, 2, 8, 4, 7, 6, 7, 3, 6, 4), P2 = c(8, 5, 6, 4, 7, 5, 6, 8, 6, 2, 3, 3, 6, 3, 4, 7) ), direction = \u0026#34;down\u0026#34;, info_sets = list(c(2,3), c(8, 9), c(10, 11), c(12, 13), c(14, 15)), show_node_id = FALSE ) Devido à falta de conhecimento por parte do jogador P1 em relação às estratégias escolhidas pelo jogador P2, encontrar uma solução para esse jogo torna-se um desafio. Especialmente em cenários onde os jogadores estão alheios às estratégias dos demais participantes, como é o caso apresentado abaixo ao tentar aplicar o conceito de indução retroativa para elucidar as escolhas estratégicas de P1 e P2.\nsolve_efg(jogo9info, concept = \u0026#34;backward\u0026#34;, quietly = FALSE) Error in backward_induction()\rError in backward_induction(game, restriction = tree_overlay): This is not a perfect-information game.\rNesse caso, há um erro ao empregar a função backward_induction() ou solve_efg(), pois o jogo em questão não se encaixa na categoria de informação perfeita (Perfect-Information). Em restriction = tree_overlay ocorre a restrição de sobreposição na estrutura da árvore, especificamente pelo uso do parâmetro info_sets.\nEm jogos de informação perfeita, os jogadores têm conhecimento completo sobre as ações e movimentos realizados por outros jogadores em cada ponto da árvore de decisão, como exemplo o jogo 7, 8 e 9. Se o jogo contém informações imperfeitas ou incertezas sobre as ações de outros jogadores, a indução reversa ou indução retroativa não pode ser aplicada diretamente, já que ela pressupõe informação perfeita.\nAo expandir o exemplo, agora com a introdução de um terceiro país \u0026quot;P3\u0026quot;, novas dimensões estratégicas emergem. Nessa situação ele possui as opções de \u0026ldquo;Ajudar\u0026rdquo; (\u0026quot;A\u0026quot;) e \u0026ldquo;Desestabilizar\u0026rdquo; (\u0026quot;D\u0026quot;). Se P3 escolher \u0026ldquo;Ajudar\u0026rdquo;, seu objetivo é promover uma abordagem cooperativa entre P1 e P2, encorajando tratados de paz e parcerias, podendo ser alcançado através de diplomacia, oferecendo incentivos econômicos ou compartilhando informações sensíveis.\nPor outro lado, se P3 optar por \u0026ldquo;Desestabilizar\u0026rdquo;, suas ações terão como alvo a erosão da confiança entre P1 e P2, ou seja, ele poderia propagar rumores, incentivar disputas territoriais ou minar acordos já existentes. Ao fazer isso, será criado um ambiente de incerteza e rivalidade, aumentando assim as chances de conflito entre os outros dois países.\njogo10 \u0026lt;- extensive_form( players = list(\u0026#34;P1\u0026#34;, # n1 rep(\u0026#34;P2\u0026#34;, 2), # n2 e n3 rep(\u0026#34;P1\u0026#34;, 4), # n4 - n7 rep(\u0026#34;P2\u0026#34;, 8), # n8 - n15 rep(\u0026#34;P3\u0026#34;, 16), # n16 - n31 rep(NA, 32)), # Nós terminais actions = list( c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n1 - n3 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n4 - n6 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n7 - n9 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n10 - n12 c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), c(\u0026#34;G\u0026#34;, \u0026#34;P\u0026#34;), # n13 - n15 # Ações do terceiro país (P3) c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), # n16 - n18 c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), # n19 - n21 c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), # n22 - n24 c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), # n25 - n27 c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;), # n28 - n30 c(\u0026#34;A\u0026#34;, \u0026#34;D\u0026#34;) # n31 ), payoffs = list( P1 = c(6, 5, 6, 4, 5, 3, 6, 2, 8, 4, 7, 6, 7, 3, 6, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5), P2 = c(8, 5, 6, 4, 7, 5, 6, 8, 6, 2, 3, 3, 6, 3, 4, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5), P3 = sample(1:9, 32, replace = TRUE) ), direction = \u0026#34;right\u0026#34;, show_node_id = FALSE ) Nesta situação, ocorre a expansão do exemplo ao adicionar mais 15 nodos, a fim de incluir o terceiro país no jogo. Além disso, a amostragem dos payoffs é estendida para 32 elementos. Uma abordagem alternativa é a definição dos payoffs de forma aleatória para P3, como realizado através da função sample(), a qual gera uma seleção aleatória de valores a partir de um vetor.\nAo empregar 1:9, 32 como argumento dessa função, é criado um vetor com valores variando de 1 a 9, ou seja, os possíveis ganhos do jogador P3 estão dentro desse intervalo. Esses valores são então repetidos 32 vezes, correspondendo ao número de elementos amostrados. A utilização de replace = TRUE permite que elementos sejam selecionados mais de uma vez na amostra, possibilitando a repetição de valores nos payoffs do país P3. Caso fosse definido replace = FALSE, cada valor apareceria apenas uma vez.\nEm resumo, essa abordagem amplia a complexidade do exemplo ao adicionar um terceiro país e introduzir aleatoriedade nos payoffs desse jogador por meio da função sample().\ns_jogo10 \u0026lt;- solve_efg(jogo9, concept = \u0026#34;backward\u0026#34;, quietly = FALSE) backward induction: [(P, G , G , G , G ), (G, G, G , G , G , P, G , G , G , P)], [(P, G , G , G , G ), (G, P, G , G , G , P, G , G , G , P)], [(P, P, G , G , G ), (P, G, G , G , G , P, G , G , G , P)], [(P, P, G , G , G ), (P, P, G , G , G , P, G , G , G , P)], [(P, G , G , G , G ), (G, G, G , G , G , P, G , P, G , P)], [(P, G , G , G , G ), (G, P, G , G , G , P, G , P, G , P)], [(P, P, G , G , G ), (P, G, G , G , G , P, G , P, G , P)], [(P, P, G , G , G ), (P, P, G , G , G , P, G , P, G , P)] A presença de P3 adiciona uma nova camada de complexidade. Sua escolha de \u0026ldquo;Ajudar\u0026rdquo; em vez de \u0026ldquo;Desestabilizar\u0026rdquo; parece ter desempenhado um papel crucial em incentivar a paz entre P1 e P2 nas primeiras rodadas. No entanto, à medida que P1 opta por \u0026ldquo;Guerra\u0026rdquo; e P2 responde da mesma forma, o equilíbrio entre os três países se torna mais delicado.\nEm síntese, a introdução de P3 com suas estratégias de \u0026ldquo;Ajudar\u0026rdquo; e \u0026ldquo;Desestabilizar\u0026rdquo; transformou a dinâmica geopolítica. As decisões agora são influenciadas pelas ações de três jogadores, levando a resultados variados e demonstrando como diferentes abordagens podem levar a cenários diversos de cooperação e conflito\nQuando se trata de um jogo com três jogadores, como no caso do jogo 9, a função to_matrix() não pode ser empregada, conforme demonstrado na tentativa a seguir ao utilizá-la.\nto_matrix(jogo10) Error in to_matrix()\rError in to_matrix(jogo10): This function only works with a two-person game.\rEsse erro ocorre pois a função to_matrix() do pacote Rgamer é projetada para trabalhar com jogos de dois jogadores. A mensagem de erro que está sendo mostrada, \u0026ldquo;This function only works with a two-person game\u0026rdquo;, significa que essa função não é capaz de lidar com jogos envolvendo três jogadores ou mais, pois limita-se a jogos de dois jogadores porque ela transforma a estrutura de um jogo em uma matriz, que é mais adequada para jogos de dois jogadores.\nQuando há três jogadores, como no exemplo apresentado, a representação em forma extensiva da árvore de decisão se torna mais clara e menos complexa do que a representação em forma normal por matriz, porém a complexidade aumenta ao considerar as possíveis soluções de indução retroativa, em que cada jogador analisa as escolhas dos outros para determinar suas próprias ações.\nCom três ou mais jogadores, a quantidade de combinações possíveis de soluções de indução retroativa cresce exponencialmente. Desse modo, surge mais cenários estratégicos a considerar, tornando impraticável a representação por matriz.\nReferências YANAI, Yusei; KAMIJO, Yoshio. Game Theory With R. Shin-Ogawacho, Shinjuku-ku, Tóquio, JP: Asakura Publishing Co,. Ltd., 2023. 244 p. ISBN 978-4-254-27024-2 C3050.\n","date":"2023-09-26T00:00:00Z","image":"https://drewmelo.github.io/blogr/p/jogos-sequenciais-e-repetidos/jogos-sequenciais-repetidos.jpg","permalink":"https://drewmelo.github.io/blogr/p/jogos-sequenciais-e-repetidos/","title":"Teoria dos Jogos no R: Jogos Sequenciais e Repetidos"},{"content":"As complicações em gestações prematuras para mulheres acima de 30 anos A gestação é um processo complexo que envolve diversos aspectos da saúde física e emocional tanto da mãe quanto do feto. As gestações prematuras representam um problema de saúde pública que afeta milhares de mulheres em todo o mundo. Esse problema se torna ainda mais significativo quando consideramos as complicações na gravidez em mulheres com mais de 30 anos.\nPortanto, é de suma importância compreender a análise estatística por trás desses fatores que podem contribuir para a ocorrência do parto prematuro em mulheres mais velhas. Abaixo, apresentamos um gráfico que ilustra a incidência de gestações prematuras em mulheres acima de 30 anos.\nNo que diz respeito às variáveis Semana de Gestação, Idade da Mãe e Consultas mencionadas no gráfico anterior, podemos observar vários fatores que estão relacionados ao nascimento prematuro de bebês. O estudo revela uma maior taxa de natalidade de crianças prematuras em mães mais velhas, baseado em uma amostra de 36 pessoas. Dessas, 20 estão situadas na faixa etária de 30 a 38 anos, com gestações entre 32 e 36 semanas e 7 ou mais consultas médicas. Essa taxa se agrava quando comparada com mães na mesma faixa etária que tiveram gestações entre menos de 22 e 28 a 31 semanas, com apenas 1 a 3 consultas ou nenhuma.\nConforme destacado por Souza (2015), as causas para esse fenômeno podem ser variadas, incluindo a saúde materna, presença de comorbidades médicas, qualidade de vida e outros fatores. Nesse sentido, o nascimento prematuro em mulheres mais velhas pode estar relacionado a complicações na implantação do embrião e no desenvolvimento placentário. Além disso, outros fatores devem ser considerados, como a exposição a fatores de risco, sejam eles ambientais ou relacionados ao estresse, que podem contribuir para o parto prematuro.\nEntretanto, é fundamental ressaltar que as análises realizadas aqui não estabelecem uma relação direta entre uma variável e outra. Cada caso é único, e nem todas as mulheres mais velhas terão um parto prematuro, assim como nem todas as gestações com outras características resultarão em nascimentos prematuros.\nRelação entre semana de gestação e peso em kg No gráfico acima, apresenta-se o diagrama de dispersão que relaciona o peso com a semana de gestação em mulheres com idades entre 12 e 45 anos. No subconjunto das mulheres acima de 30 anos, observamos uma amostra composta por 19 mulheres, divididas entre os intervalos de gestação de menos de 22 a 36 semanas e pesos de 1 a 3 quilogramas.\nNotou-se que a maioria dos casos se concentra nos intervalos de 2 a 3 quilogramas, com 32 a 36 semanas de gestação, abrangendo sete pessoas, e de 1 a 2 quilogramas, também com 32 a 36 semanas de gestação, com seis casos. Esta análise está relacionada novamente à variável da gestação, mas agora considerando a relação com o peso dos bebês prematuros. Este cenário é comum, pois é amplamente conhecido que quanto menor a semana de gestação, menor a quantidade de nutrientes que o bebê recebe durante o desenvolvimento no útero. Isso, por sua vez, está diretamente ligado ao menor peso e à estrutura orgânica reduzida do recém-nascido.\nA grande maioria dos bebês prematuros, como indicado neste estudo e como pode ser observado no gráfico anterior, nasce com peso abaixo da média esperada para bebês nascidos a termo.\nRelação entre escolaridade e idade da mãe Já neste gráfico, podemos observar condições que, à primeira vista, podem parecer difíceis de relacionar, mas o estudo realizado revelou o contrário. Um exemplo notável é a relação entre o nível de instrução e a taxa de nascimentos prematuros. Na amostra de 36 mães com mais de 30 anos que tiveram gestações com menos de 37 semanas, notou-se que nenhuma delas possuía ensino superior. Uma análise mais detalhada desses 36 indivíduos revela que 6 estavam distribuídos em gestações com menos de 22 a 31 semanas, com apenas uma mulher tendo completado o ensino médio.\nDe acordo com Kramer et al. (2000), a falta de educação pode afetar a capacidade das mulheres de acessar informações cruciais sobre saúde e cuidados pré-natais adequados. Mulheres com menor nível de escolaridade podem ter menos acesso a informações precisas e atualizadas sobre saúde reprodutiva, incluindo a prevenção de complicações durante a gravidez e o parto.\nNessas três análises que abrangem as variáveis Idade da Mãe, Escolaridade, Gestação e Peso, percebe-se que essas quatro variáveis estão de alguma forma correlacionadas, embora não diretamente. O nascimento prematuro, como evidenciado no gráfico da relação entre semana de gestação e peso, frequentemente ocorre em bebês com peso entre 1 kg e 3 kg, principalmente quando as mães são mais velhas, o que aumenta ainda mais o risco. Ao comparar Idade da Mãe e Escolaridade, observa-se que à medida que a idade das mães aumenta além dos 30 anos, o número de mulheres com ensino superior diminui, o que, por sua vez, reduz o acesso à informação e diminui a frequência das consultas pré-natais, aumentando os riscos de nascimento prematuro.\nAlém disso, a falta de recursos financeiros, frequentemente causada pela ausência de ensino superior em mulheres mais velhas, pode limitar o acesso a serviços públicos de qualidade, como exames pré-natais regulares e assistência ao parto por profissionais qualificados.\nReferências KRAMER, M. S. et al. Socio-economic disparities in pregnancy outcome: why do the poor fare so poorly? Paediatric and perinatal epidemiology, v. 14, n. 3, p. 194-210, 2000. Disponível em: https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-3016.2000.00265.x\r. Acesso em: 19 mar. 2021.\nMENEZES, A. L. Como assim, cultura da pedofilia? Politize. 2022. Disponível em: https://www.politize.com.br/cultura-do-estupro-como-assim/\r. Acesso em: 19 mar. 2021.\nSOUZA, R. T. Uma análise do parto prematuro terapêutico no contexto da prematuridade no Brasil. Dissertação. Campinas (SP): Universidade Estadual de Campinas, 2015.\n","date":"2023-09-22T00:00:00Z","image":"https://drewmelo.github.io/blogr/p/analise-do-sinasc-granja-ce/thumb-analise-sinasc-ce.jpg","permalink":"https://drewmelo.github.io/blogr/p/analise-do-sinasc-granja-ce/","title":"Análise do SINASC - Granja - CE"},{"content":"Ao longo das últimas décadas, testemunhamos avanços tecnológicos que alteraram a forma como vivemos, seja no trabalho ou no modo como nos comunicamos. No cerne dessa revolução está a internet, um sistema global de informações que conecta pessoas, empresas e instituições em diferentes partes do mundo. Seu surgimento, juntamente com o crescimento exponencial da quantidade de dados gerados e armazenados em servidores levaram a uma necessidade sem precedentes para aplicar esses conhecimentos em uma escala maior. Dessa forma, com o avanço dessa tecnologia ascendeu o desenvolvimento e popularização da Data Science, ou simplesmente Ciência de Dados.\nA Ciência de Dados é um campo multidisciplinar que abrange a análise de dados estruturados, que são fixos e organizados, bem como de dados não estruturados, que são flexíveis e dinâmicos, com técnicas e algoritmos para extração e exploração de informações a partir de conjuntos de bases complexas. Nesse quesito, um especialista buscará envolver a coleta, processamento, análise e interpretação desses dados com o objetivo de obter insights e conhecimentos relevantes para a área econômica.\nAlgumas técnicas são essenciais para análise ou extração de dados, como Web Scraping, que consiste na utilização da automatização para obter pontos imensuráveis de dados estruturados da internet, em contraposição ao processo do Text Mining ou Text Analytics, na extração de dados não estruturados de fontes online. Essas duas técnicas combinadas com Machine Learning ou Aprendizado de Máquina, podem fazer o diferencial na carreira de um economista no que diz respeito à análise de mercado e previsões econômicas.\nÉ durante a fase de análise exploratória de dados que o modelo de previsão de preços de ativos e avaliação de risco financeiro é construído. Além disso, técnicas como Text Analytics e Machine Learning, têm uma aplicação valiosa na análise de sentimentos, principalmente quando estamos lidando com dados não estruturados. Dessa forma, é possível detectar as opiniões positivas, negativas ou neutras dos consumidores em relação a um produto ou serviço. Essa capacidade de compreensão do feedback dos clientes em relação aos produtos é de extrema utilidade para identificar tendências e problemas relacionados aos produtos das empresas.\na era do “Big Data”, estamos lidando com um volume excessivo de dados econômicos, como indicadores macroeconômicos, séries temporais e informações de mercado. Esse cenário apresenta desafios significativos em relação ao armazenamento, processamento e privacidade dos dados. No entanto, também oferece aos profissionais a oportunidade de observar padrões complexos no comportamento econômico, o que permite análises abrangentes, previsões mais precisas e o desenvolvimento de estratégias eficientes.\nOs avanços tecnológicos proporcionaram aos cientistas de dados ferramentas inteligentes e poderosas para explorar e compreender as bases de dados. Entretanto, é fundamental destacar o papel crucial do conhecimento e da experiência do economista nesse processo. Ao combinar o conhecimento teórico com as técnicas de Ciência de Dados, o profissional em questão é capaz de interpretar as relações de causa e efeito, aplicando seu conhecimento econômico para extrair insights importantes. Com isso, adquirindo uma posição estratégica em um mundo cada vez mais orientado por dados, impulsionando o progresso econômico e embasando a tomada de decisões fundamentadas.\n","date":"2023-09-21T00:00:00Z","image":"https://drewmelo.github.io/blogr/p/ciencia-de-dados-na-economia/data-science-economia.jpg","permalink":"https://drewmelo.github.io/blogr/p/ciencia-de-dados-na-economia/","title":"Ciência de Dados na Economia"},{"content":"\rIntrodução A teoria dos jogos é um ramo da matemática que explora as interações estratégicas em que as decisões de um indivíduo são influenciadas pelo conflito e cooperação de outros participantes. Em relação ao campo das ciências econômicas, essa teoria desempenha um papel fundamental ao analisar como as pessoas realizam escolhas estratégicas diante de objetivos concorrentes em um contexto de escassez.\nUma aplicação interessante da teoria dos jogos na área da economia é a sua combinação com simulações de aprendizado. Por exemplo, em um cenário em que diferentes empresas competem para estabelecer preços em um mercado, é possível utilizar a teoria dos jogos em conjunto com modelos de aprendizado. Nesses modelos, as empresas podem aprender ao longo do tempo a tomar decisões estratégicas mais eficientes e adaptar suas estratégias com base nas escolhas e resultados passados. Dessa forma, as empresas podem ajustar gradualmente suas ações para obter melhores resultados e alcançar equilíbrios de longo prazo em um ambiente competitivo.\nEste tutorial tem como objetivo ensinar como aplicar a teoria dos jogos no ambiente R, utilizando o pacote Rgamer, desenvolvido por Yusei Yanai, Ph.D. em Ciência Política, e Yoshio Kamijo, Especialista em Economia Experimental, Teoria dos Jogos, Teoria Comportamental dos Jogos e Design do Futuro. Desse modo, através da integração de funções de modelos de aprendizado, exploraremos a teoria dos jogos e sua aplicação prática. O pacote oferece representações visuais de jogos para dois ou mais jogadores e possibilita encontrar equilíbrios de Nash, proporcionando uma compreensão mais profunda dos conceitos fundamentais no contexto das Ciências Econômicas. Com o Rgamer, tem-se disponível uma ferramenta poderosa para a análise e simulação de interações estratégicas, tornando o estudo do assunto ainda mais acessível e abrangente.\nPacotes Para realização dos passos seguintes, será necessário a instalação e ativação do pacote:\n# install.packages(\u0026#34;devtools\u0026#34;) # devtools::install_github(\u0026#34;yukiyanai/rgamer\u0026#34;) library(rgamer) library(utf8) Jogos Simultâneos Os jogos simultâneos representam uma categoria fundamental na teoria dos jogos, na qual todos os jogadores tomam suas decisões ao mesmo tempo, sem qualquer conhecimento prévio das escolhas dos outros jogadores. No ambiente de programação R, o pacote Rgamer oferece uma ampla gama de recursos que facilitam a modelagem de jogos simultâneos, o cálculo de equilíbrios de Nash, a representação gráfica e a análise de estratégias dominantes.\nEstratégias Puras O dilema dos prisioneiros é um clássico exemplo de jogo de estratégia pura em teoria dos jogos que envolve dois jogadores que enfrentam uma escolha difícil entre cooperar ou trair o outro jogador. Através da função normal_form() teremos dois exemplos desse tipo forma normal de jogo em dois métodos.\nMétodo 1\rMétodo 2\rNeste primeiro método, é necessário definir os pagamentos para cada célula da matriz do jogo utilizando o argumento cells, que é configurado como uma lista, no caso list(). Também é necessário especificar os jogadores, que, neste exemplo, são \u0026quot;Bonnie\u0026quot; e \u0026quot;Clyde\u0026quot;, utilizando o argumento players, em que as estratégias, \u0026quot;Confessar\u0026quot; e \u0026quot;Não Confessar\u0026quot;, respectivamente, são definidas nos argumentos s1 e s2 para eles.\nO argumento lógico byrow pode ser configurado como TRUE ou FALSE. Quando definido como TRUE, os valores na lista dentro das células são especificados por linha, seguindo a ordem das estratégias \u0026ldquo;Confessar\u0026rdquo; e \u0026ldquo;Não Confessar\u0026rdquo;, respectivamente, para cada jogador. Se configurado como FALSE, os valores serão organizados por coluna.\njogo1 \u0026lt;- normal_form( players = c(\u0026#34;Bonnie\u0026#34;, \u0026#34;Clyde\u0026#34;), s1 = c(\u0026#34;Confessar\u0026#34;, \u0026#34;Não Confessar\u0026#34;), s2 = c(\u0026#34;Confessar\u0026#34;, \u0026#34;Não Confessar\u0026#34;), cells = list(c(-8, -8), c(0, -15), c(-15, 0), c(-1, -1)), byrow = TRUE) Para encontrar a solução do primeiro método é necessário a função solve_nfg() e o argumento show_table = TRUE para obter a tabela e o equilíbrio de Nash.\ns_jogo1 \u0026lt;- solve_nfg(jogo1, show_table = TRUE) Pure-strategy NE: [Confessar, Confessar] Clyde\rstrategy\rConfessar\rNão Confessar\rBonnie\rConfessar\r-8^, -8^\r0^, -15\rNão Confessar\r-15, 0^\r-1, -1\rConsiderando o fator \u0026ldquo;traição\u0026rdquo;, escolher confessar é sempre a melhor opção para Bonnie, independentemente da escolha de Clyde. A estratégia de não confessar pode levar a resultados piores se o outro jogador escolher confessar. Portanto, confessar é a estratégia dominante para ambos, incentivando a cooperação mútua.\nNo segundo método, por padrão, temos os payoffs1 e payoffs2, onde especificamos os ganhos de cada jogador. Neste outro exemplo dois postos de gasolina, \u0026quot;OilFlex\u0026quot; e \u0026quot;EconoGas\u0026quot;, competem para ver quem obtém o maior lucro e conquista a maior fatia de mercado na venda de combustíveis. Nesse cenário, as estratégias definidas para cada posto serão \u0026quot;Manter Preço\u0026quot; e \u0026quot;Reduzir Preço\u0026quot;.\njogo2 \u0026lt;- normal_form( players = c(\u0026#34;OilFlex\u0026#34;, \u0026#34;EconoGas\u0026#34;), s1 = c(\u0026#34;Manter Preço\u0026#34;, \u0026#34;Reduzir Preço\u0026#34;), s2 = c(\u0026#34;Manter Preço\u0026#34;, \u0026#34;Reduzir Preço\u0026#34;), payoffs1 = c(50, 60, 30, 40), payoffs2 = c(50, 30, 60, 40)) Para obter a solução utilizando o segundo método, assim como no primeiro, também é possível definir o argumento show_table como FALSE.\ns_jogo2 \u0026lt;- solve_nfg(jogo2, show_table = FALSE) Pure-strategy NE: [Reduzir Preço, Reduzir Preço] Sendo necessário o comando $table para mostrar a tabela, juntamente com o equilíbrio de Nash.\ns_jogo2$table EconoGas\rstrategy Manter Preço Reduzir Preço OilFlex Manter Preço 50, 50 30, 60^ Reduzir Preço 60^, 30 40^, 40^ Se os dois concordarem em manter o preço original, cada um ganha 50 mil por mês. Se um deles reduzir o preço, ele recebe 60 mil, enquanto o outro ganha apenas 30 mil. Caso ambos decidam reduzir o preço, cada um ganha 40 mil. O ponto de equilíbrio é quando ambos reduzem o preço, pois essa é a estratégia dominante e resulta em um equilíbrio de Nash sem cooperação.\nEstratégias Dominantes As estratégias estritamente dominantes referem-se a uma situação em que um jogador tem uma estratégia que é sempre melhor do que qualquer outra estratégia que ele possa escolher, independentemente das escolhas dos outros jogadores.\nNo exemplo a seguir, os jogadores \u0026quot;Pedro\u0026quot; e \u0026quot;Ana\u0026quot; são especificados no argumento players. Neste jogo, ao contrário dos dois exemplos anteriores, cada jogador possui 3 estratégias disponíveis: \u0026quot;Bar\u0026quot;, \u0026quot;Museu\u0026quot; e \u0026quot;Café\u0026quot;. Dessa forma, será necessário aumentar o número de elementos nas matrizes payoffs1 e payoffs2, agora contendo um total de 9 elementos.\njogo3 \u0026lt;- normal_form( players = c(\u0026#34;Pedro\u0026#34;, \u0026#34;Ana\u0026#34;), s1 = c(\u0026#34;Bar\u0026#34;, \u0026#34;Museu\u0026#34;, \u0026#34;Café\u0026#34;), s2 = c(\u0026#34;Bar\u0026#34;, \u0026#34;Museu\u0026#34;, \u0026#34;Café\u0026#34;), payoffs1 = c(6, 2, 1, 6, 5, 1, 4, 2, 3), payoffs2 = c(4, 1, 1, 3, 5, 3, 2, 2, 6)) O argumento lógico mark_br desempenha a função de destacar as melhores respostas (best responses) na tabela de solução. Quando é definido como FALSE, as melhores respostas não são destacadas na tabela. O valor padrão para mark_br é TRUE, o que significa que, caso esse argumento na função não seja incluído na função, a tabela exibirá automaticamente o equilíbrio de Nash.\nNesse caso, o equilíbrio de Nash em conjunto com a mensagem não serão exibidas, já que ao configurar quietly como TRUE, está sendo implicitamente ocultado a mensagem de melhores respostas. Essa configuração flexível permite controlar tanto a exibição da mensagem quanto o destaque do Equilíbrio de Nash, de acordo com as preferências.\ns_jogo3 \u0026lt;- solve_nfg(jogo3, show_table = TRUE, mark_br = FALSE, quietly = TRUE) Ana\rstrategy Bar Museu Café Pedro Bar 6, 4 6, 3 4, 2 Museu 2, 1 5, 5 2, 2 Café 1, 1 1, 3 3, 6 Na função dom() com type = \u0026quot;dominant\u0026quot;, são identificadas as estratégias estritamente dominantes para cada jogador no jogo. Por meio dessa configuração é possível identificar as estratégias que são sempre a melhor escolha, independentemente das ações tomadas pelos outros jogadores.\nDiferentemente do parâmetro quietly encontrado em funções como solve_nfg() e outras do pacote Rgamer, é essencial demonstrar que ao configurar esse parâmetro como FALSE na função dom(), ela passa a exibir uma mensagem que identifica quais estratégias são estritamente dominantes.\ndominant_j3 \u0026lt;- dom(jogo3, type = \u0026#34;dominant\u0026#34;, quietly = FALSE) Pedro\u0026#39;s dominant strategy: Bar Pedro\u0026#39;s weakly dominant strategy: Bar Ana\u0026#39;s dominant strategy: NA Ana\u0026#39;s weakly dominant strategy: NA No primeiro conjunto de resultados, ao analisar as estratégias estritamente dominantes, identificamos que a estratégia \u0026ldquo;Bar\u0026rdquo; é a melhor resposta para Pedro. Nesse contexto, essa estratégia é a escolha que Pedro deve realizar independentemente das escolhas de Ana.\nContudo, é importante ressaltar que a existência de estratégias estritamente dominantes em jogos não é uma característica universal, variando conforme as regras e as interações específicas dentro de cada jogo. Desse modo, quando tais estratégias estão presentes, elas desempenham um papel crucial na análise e na formulação de decisões estratégicas.\nEstratégias Dominadas A dominância fraca é um dos critérios usados para identificar estratégias não razoáveis ou não ótimas em um jogo. Ela indica a existência de outra estratégia que é, no mínimo, tão boa quanto a estratégia dominada fracamente, mas que pode oferecer um melhor resultado em algumas situações específicas.\nNo mesmo exemplo, faremos uma alteração no parâmetro type, em que anteriormente estava definido como \u0026quot;dominant\u0026quot;, mas agora será configurado como \u0026quot;dominated\u0026quot;. O objetivo dessa modificação é identificar estratégias que são dominadas e fracamente dominadas tanto para Pedro quanto para Ana.\ndominated_j3 \u0026lt;- dom(jogo3, type = \u0026#34;dominated\u0026#34;, quietly = FALSE) Pedro\u0026#39;s dominated strategy: Museu, Café Pedro\u0026#39;s weakly dominated strategy: Museu, Café Ana\u0026#39;s dominated strategy: NA Ana\u0026#39;s weakly dominated strategy: NA Através da análise do segundo conjunto, podemos evidenciar que para o jogador Pedro, as estratégias \u0026ldquo;Museu\u0026rdquo; e \u0026ldquo;Café\u0026rdquo; são dominadas por outra estratégia, pois sempre há uma escolha alternativa, no caso \u0026ldquo;Bar\u0026rdquo;, que leva a um resultado melhor, independentemente da escolha do outro jogador.\nNa perspectiva de Ana, em ambos os conjuntos de resultados, não foram encontradas estratégias dominadas nem dominantes, o que indica que suas escolhas são consideradas melhores respostas dadas as escolhas de Pedro.\nbr_j3 \u0026lt;- solve_nfg(jogo3) Pure-strategy NE: [Bar, Bar] Ana\rstrategy Bar Museu Café Pedro Bar 6^, 4^ 6^, 3 4^, 2 Museu 2, 1 5, 5^ 2, 2 Café 1, 1 1, 3 3, 6^ Agora, ao verificar as melhores estratégias para o jogador 1 e 2, a mensagem e o destaque do Equilíbrio de Nash podem ser exibidos. Dentro da estrutura da função solve_nfg(), ao remover o parâmetro show_table, a tabela será exibida por padrão, assim como ocorre com outros parâmetros como quietly e mark_br.\nEstratégias Mistas Solução por br_plot\rPayoff por função\rPrecisão do br_plot\rImagine um cenário onde o Governo e uma pessoa pobre estão interagindo. O Governo tem duas estratégias possíveis: \u0026ldquo;Ajuda\u0026rdquo; e \u0026ldquo;Não Ajuda\u0026rdquo;, enquanto a pessoa pobre tem duas estratégias: \u0026ldquo;Trabalha\u0026rdquo; e \u0026ldquo;Vadia\u0026rdquo;.\njogo4 \u0026lt;- normal_form( players = c(\u0026#34;Governo\u0026#34;, \u0026#34;Pobre\u0026#34;), s1 = c(\u0026#34;Ajuda\u0026#34;, \u0026#34;Não Ajuda\u0026#34;), s2 = c(\u0026#34;Trabalha\u0026#34;, \u0026#34;Vadia\u0026#34;), payoffs1 = c(3, -1, -1, 0), payoffs2 = c(2, 1, 3, 0)) Nesse jogo, o Governo e o pobre podem optar por estratégias puras, ou seja, escolher uma ação específica com certeza, ou podem utilizar estratégias mistas, ou seja, fazer escolhas ponderadas com base em probabilidades. Através do parâmetro mixed = TRUE, podemos encontrar a solução para esse tipo de jogo para as estratégias mistas.\ns_jogo4 \u0026lt;- solve_nfg(jogo4, mixed = TRUE, show_table = FALSE) Pure strategy NE does not exist. Mixed-strategy NE: [(1/2, 1/2), (1/5, 4/5)] The obtained mixed-strategy NE might be only a part of the solutions. Please examine br_plot (best response plot) carefully. Com a função br_plot (best response plot) ou gráfico de melhores respostas é possível se chegar a maximização do payoff esperado.\ns_jogo4$br_plot A função de payoff em estratégias mistas é usada para representar o resultado esperado que um jogador obtém ao escolher uma determinada ação com probabilidade ou com incerteza. No exemplo a seguir estão as funções de payoff para as estratégias dos jogadores A e B.\nJogador: $\\{A, B\\}$\nEstratégia: $\\{x \\in [0, 1], y \\in [0, 1] \\}$\nPayoff: $\\{f_x(x, y) = -3x^2 + (1 - y) \\times 2x, f_y(x, y) = -2y^2 + (1 - x) \\times 3y\\}$\nDesse modo, é possível definir um jogo fornecendo as funções de payoff como vetores de caracteres usando a função normal_form(). Nos parâmetros par1_lim e par2_lim estão configurados os valores entre 0 e 1, o que significa que as estratégias ou escolhas dos jogadores \u0026ldquo;A\u0026rdquo; e \u0026ldquo;B\u0026rdquo; estão limitadas a esse intervalo. Esses argumentos definem os limites para os eixos, no caso, \u0026quot;x\u0026quot; e \u0026quot;y\u0026quot; contidas em pars.\njogo5 \u0026lt;- normal_form( players = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;), payoffs1 = \u0026#34;-4*x^2 + (1-y) * 2*x\u0026#34;, payoffs2 = \u0026#34;-2*y^2 + (1-x) * 3*y\u0026#34;, par1_lim = c(0, 1), par2_lim = c(0, 1), pars = c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) Com a construção da estrutura do jogo na forma normal, temos a solução dele a apartir da função solve_nfg().\ns_jogo5 \u0026lt;- solve_nfg(jogo5) approximated NE: (0.1, 0.7) The obtained NE might be only a part of the solutions. Please examine br_plot (best response plot) carefully. Nesse método alternativo, é possível definir os resultados de um jogo na forma normal, utilizando function da linguagem R\nJogador: $\\{A, B\\}$\nEstratégia: $\\{x \\in [0, 1], y \\in [0, 1] \\}$\nPayoff: $\\{f_x(x, y) = -nx^a + (b - y) \\times px, f_y(x, y) = -my^s + (t - x) \\times qy\\}$\n# Função do jogador 1 f_x \u0026lt;- function(x, y, a, b, n, p) { -n*x^a + (b - y) * p*x } # Função do jogador 2 f_y \u0026lt;- function(x, y, s, t, m, q) { -m*y^s + (t - x) * q*y } Após a definição das funções para os jogadores 1 e 2, podemos incorporá-las dentro da normal_form() nos parâmetros payoffs1 e payoffs2.\njogo6 \u0026lt;- normal_form( players = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;), payoffs1 = f_x, payoffs2 = f_y, par1_lim = c(0, 1), par2_lim = c(0, 1), pars = c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) Para obter uma solução aproximada numericamente usando o solve_nfg(), é necessário definir os valores dos parâmetros da função que devem ser tratados como constantes, utilizando os argumentos cons1 e cons2, ambos aceitando uma lista de nomes. Além disso, é possível evitar que o gráfico das melhores respostas seja exibido, definindo plot = FALSE.\nspf_jogo6 \u0026lt;- solve_nfg( game = jogo6, cons1 = list( a = 2, b = 1, n = 4, p = 2 ), cons2 = list( s = 2, t = 1, m = 2, q = 3 ), plot = FALSE) ## approximated NE: (0.1, 0.7) ## The obtained NE might be only a part of the solutions. ## Please examine br_plot (best response plot) carefully. É possível ajustar a precisão da aproximação através do parâmetro precision (por padrão, precision = 1). Ao aumentar o valor, o cálculo das soluções será feito com maior detalhamento, resultando em uma aproximação mais precisa dos resultados. No entanto, é importante notar que quanto maior o valor desse parâmetro, mais tempo o processo de cálculo pode levar, especialmente para jogos mais complexos com muitas estratégias e jogadores. Portanto, é recomendado ajustar o valor da precisão de acordo com a complexidade do jogo e a necessidade de precisão dos resultados.\ns_jogo6 \u0026lt;- solve_nfg( game = jogo6, cons1 = list( a = 2, b = 1, n = 4, p = 2 ), cons2 = list( s = 2, t = 1, m = 2, q = 3 ), precision = 3) approximated NE: (0.077, 0.692) The obtained NE might be only a part of the solutions. Please examine br_plot (best response plot) carefully. Para extrair o gráfico das melhores respostas com o ponto de Equilíbrio de Nash (NE) marcado, é possível utilizar a função br_plot_NE. Esse gráfico mostra como as estratégias dos jogadores podem mudar e se adaptar para alcançar o NE.\ns_jogo6$br_plot_NE Com estratégias mistas, os jogadores podem tomar decisões aleatórias com diferentes probabilidades para cada ação. Isso torna o resultado do jogo mais incerto, pois o desfecho dependerá das escolhas aleatórias feitas por cada jogador.\nOutros Exemplos Parâmetro Discretize\rBatalha dos Sexos\rNeste jogo, duas empresas, a \u0026ldquo;Empresa A\u0026rdquo; e a \u0026ldquo;Empresa B\u0026rdquo;, participam de uma disputa para ganhar um contrato. Cada uma delas deve escolher um lance entre 1 e 10 milhões de reais.\nSe a \u0026ldquo;Empresa A\u0026rdquo; fizer o lance mais alto, ela ganha o contrato e recebe uma recompensa de 10 milhões. Enquanto isso, a \u0026ldquo;Empresa B\u0026rdquo; não ganha o contrato e ela acaba tendo prejuízo de 1 milhão.\nPor outro lado, se a \u0026ldquo;Empresa A\u0026rdquo; fizer o lance mais alto, ela ganha o contrato e recebe a recompensa de 10 milhões. Enquanto isso, a \u0026ldquo;Empresa B\u0026rdquo; não ganha o contrato e perde 1 milhão.\nSe ambas as empresas fizerem exatamente o mesmo lance, elas não conseguem diferenciar suas ofertas, e o contrato é anulado. Nesse caso, nenhuma das empresas recebe a recompensa.\nCom base no exemplo mencionado anteriormente, utilizaremos novamente a palavra-chave function do R para representar a função de payoff. Isso se deve ao maior espaço estratégico presente no jogo, o qual possibilita mais combinações de lances e, por consequência, mais resultados em comparação com o jogo do dilema dos prisioneiros.\n# Payoff do jogador 1 func_payoff1 \u0026lt;- function(a, b) { if (a \u0026lt; b) { profit \u0026lt;- -1 } else if (a == b) { profit \u0026lt;- 0 } else { profit \u0026lt;- 10 } profit } # Payoff do jogador 2 func_payoff2 \u0026lt;- function(a, b){ if (a \u0026gt; b) { profit \u0026lt;- -1 } else if (a == b) { profit \u0026lt;- 0 } else { profit \u0026lt;- 10 } profit } Após a definição das funções de payoff, podemos passar o exemplo acima para a função normal_form(), utilizando as condições de func_payoff1 e func_payoff2.\njogo11 \u0026lt;- normal_form( players = c(\u0026#34;Empresa A\u0026#34;, \u0026#34;Empresa B\u0026#34;), payoffs1 = func_payoff1, payoffs2 = func_payoff2, pars = c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;), s1 = c(seq(1, 10,1)), s2 = c(seq(1, 10,1)), discretize = TRUE) A opção discretize = TRUE é usada quando o conjunto contínuo de estratégias é muito grande, tornando a avaliação completa computacionalmente custosa. Nesse caso, o jogo é avaliado apenas em um conjunto específico de pontos discretos, em vez de considerar todas as combinações possíveis de estratégias contínuas. O padrão é discretize = FALSE, que significa que o jogo é avaliado considerando todas as possíveis combinações contínuas de estratégias.\nNesse contexto, na função solve_nfg(), o parâmetro mark_br será definido como FALSE, uma vez que não haverá marcação das melhores respostas para cada estratégia do oponente, devido à consideração restrita a pontos discretos ao invés de todas as combinações contínuas de estratégias.\ns_jogo11 \u0026lt;- solve_nfg(jogo11, mark_br = FALSE) Pure-strategy NE: [10, 10] Empresa B\rstrategy 1 2 3 4 5 6 7 8 9 10 Empresa A 1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 2 10, -1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 3 10, -1 10, -1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 4 10, -1 10, -1 10, -1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 5 10, -1 10, -1 10, -1 10, -1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 -1, 10 6 10, -1 10, -1 10, -1 10, -1 10, -1 0, 0 -1, 10 -1, 10 -1, 10 -1, 10 7 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 0, 0 -1, 10 -1, 10 -1, 10 8 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 0, 0 -1, 10 -1, 10 9 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 0, 0 -1, 10 10 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 10, -1 0, 0 A Batalha dos Sexos é um exemplo clássico na teoria dos jogos que ilustra a situação em que dois jogadores têm preferências diferentes, mas desejam coordenar suas ações. Neste exemplo, consideramos um casal composto por um homem e uma mulher que precisam decidir entre duas atividades: assistir a um jogo de futebol ou assistir a um balé.\nSuponha que o marido prefira assistir a um jogo de futebol, enquanto a esposa prefira assistir a um balé. No entanto, ambos preferem estar juntos do que fazer atividades separadas. Portanto, eles precisam chegar a um acordo sobre qual evento assistir juntos.\njogo12 \u0026lt;- normal_form( players = c(\u0026#34;Marido\u0026#34;, \u0026#34;Esposa\u0026#34;), s1 = c(\u0026#34;Futebol(p)\u0026#34;, \u0026#34;Balé(1-p)\u0026#34;), s2 = c(\u0026#34;Futebol(q)\u0026#34;, \u0026#34;Balé(1-q)\u0026#34;), payoffs1 = c(10, 1, 2, 5), payoffs2 = c(6, 2, 3, 10)) # Transformando o jogo 12 em tabela table_jogo12 \u0026lt;- solve_nfg(jogo12, show_table = TRUE, mark_br = FALSE) Pure-strategy NE: [Futebol(p), Futebol(q)], [Balé(1-p), Balé(1-q)] Esposa\rstrategy Futebol(q) Balé(1-q) Marido Futebol(p) 10, 6 2, 3 Balé(1-p) 1, 2 5, 10 A utilidade esperada dos dois é calculada com base na fórmula que leva em conta as probabilidades $p$ e $q$ presentes na tabela acima. Simplificamos e combinamos os termos para obter o resultado da utilidade esperada.\n$E(U_{M}) = 10pq + 2p(1 - q) + 1(1 - p)q + 5(1 - p)(1 - q)$\n$E(U_{M}) = 10pq + 2p - 2pq + q - pq + 5 - 5p - 5q + 5pq$\n$E(U_{M}) = 12pq - 4q - 3p + 5$\n${\\large{\\frac{\\partial U_{M}}{\\partial p}}} = 12pq - 4q - 3p + 5$\nPara encontrar o valor de $q$ que maximiza a utilidade esperada do marido, igualamos a derivada parcial em relação a $q$ a zero:\n$12q - 3 = 0$\n$q = \\frac{1}{4}$\nCom base na resposta anterior, pode-se usar a mesma lógica para calcular a utilidade esperada da esposa.\n$E(U_{E}) = 6pq + 3p(1-q) + 2(1-p)q + 10(1-p)(1-q)$\n$E(U_{E}) = 6pq + 3p - 3pq + 2q - 2pq + 10 - 10p - 10q + 10pq$\n$E(U_{E}) = 11pq - 7p - 8q + 10$\n${\\large{\\frac{\\partial U_{E}}{\\partial q}}} = 11pq - 7p - 8q + 10$\nPara encontrar o valor de $p$ que maximiza a utilidade esperada, igualamos a derivada parcial em relação a $p$ a zero:\n$11p - 8 = 0$\n$p = \\frac{8}{11}$\nO resultado da utilidade esperada do casal pode ser visualizado de forma gráfica utilizando a função br_plot.\ntable_jogo12$br_plot Referências HAZRA, Tanmoy; ANJARIA, Kushal. Applications of game theory in deep learning: a survey. Multimedia Tools and Applications, v. 81, n. 6, p. 8963-8994, 2022. DOI: https://doi.org/10.1007/s11042-022-12153-2\r.\nMANKIW, N. Gregory et al. Introdução à economia. 2005.\nYANAI, Yusei; KAMIJO, Yoshio. Game Theory With R. Shin-Ogawacho, Shinjuku-ku, Tóquio, JP: Asakura Publishing Co,. Ltd., 2023. 244 p. ISBN 978-4-254-27024-2 C3050.\n","date":"2023-09-16T00:00:00Z","image":"https://drewmelo.github.io/blogr/p/jogos-simultaneos/jogos-simultaneos.jpg","permalink":"https://drewmelo.github.io/blogr/p/jogos-simultaneos/","title":"Teoria dos Jogos no R: Jogos Simultâneos"},{"content":"Neste blog, criado por mim, um estudante do curso de Ciência Econômicas\n","date":"2023-09-15T00:00:00Z","image":"https://drewmelo.github.io/blogr/p/sobre-o-blog/sobre-o-blog2.jpg","permalink":"https://drewmelo.github.io/blogr/p/sobre-o-blog/","title":"Sobre o blog"}]
